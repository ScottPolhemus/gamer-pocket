let XAudioJSResampledBuffer=[],XAudioJSOutputBuffer=[],XAudioJSResampleBufferStart=0,XAudioJSResampleBufferEnd=0,XAudioJSResampleBufferSize=0,XAudioJSChannelsAllocated=1;self.onmessage=e=>{const u=e.data;switch(u[0]){case 0:const e=u[1],f=e.length;for(let u=0;u<f;u++)XAudioJSResampledBuffer[XAudioJSResampleBufferEnd++]=e[u],XAudioJSResampleBufferEnd==XAudioJSResampleBufferSize&&(XAudioJSResampleBufferEnd=0),XAudioJSResampleBufferStart==XAudioJSResampleBufferEnd&&(XAudioJSResampleBufferStart+=XAudioJSChannelsAllocated,XAudioJSResampleBufferStart==XAudioJSResampleBufferSize&&(XAudioJSResampleBufferStart=0));break;case 1:XAudioJSResampleBufferSize=u[1],XAudioJSChannelsAllocated=u[2],XAudioJSResampledBuffer=new Float32Array(XAudioJSResampleBufferSize)}};const XAudioJSResampledSamplesLeft=()=>(XAudioJSResampleBufferStart<=XAudioJSResampleBufferEnd?0:XAudioJSResampleBufferSize)+XAudioJSResampleBufferEnd-XAudioJSResampleBufferStart;self.onprocessmedia=e=>{var u=e.audioLength,f=u*e.audioChannels;f>XAudioJSOutputBuffer.length&&(XAudioJSOutputBuffer=new Float32Array(f));for(var a=Math.min(u,((XAudioJSResampleBufferStart<=XAudioJSResampleBufferEnd?0:XAudioJSResampleBufferSize)+XAudioJSResampleBufferEnd-XAudioJSResampleBufferStart)/XAudioJSChannelsAllocated),d=0,r=0;d<a;++d)for(r=d;r<f;r+=u)XAudioJSOutputBuffer[r]=XAudioJSResampledBuffer[XAudioJSResampleBufferStart++],XAudioJSResampleBufferStart==XAudioJSResampleBufferSize&&(XAudioJSResampleBufferStart=0);for(;d<u;)for(r=d++;r<f;r+=u)XAudioJSOutputBuffer[r]=0;e.writeAudio(XAudioJSOutputBuffer.subarray(0,f)),self.postMessage(e.audioLength)};